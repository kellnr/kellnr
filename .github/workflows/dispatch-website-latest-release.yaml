name: dispatch-website-latest-release

on:
  workflow_dispatch:
    inputs:
      website_owner:
        description: GitHub org/user that owns the website repo
        required: false
        default: kellnr
        type: string
      website_repo:
        description: Target repo name (will receive repository_dispatch)
        required: false
        default: website
        type: string
      event_type:
        description: repository_dispatch event type to send
        required: false
        default: kellnr_release_notes
        type: string
      source_owner:
        description: GitHub org/user that owns the source repo (this repo)
        required: false
        default: kellnr
        type: string
      source_repo:
        description: Source repo name to read the latest release from
        required: false
        default: kellnr
        type: string
      release_tag:
        description: Optional. If set, dispatch this specific tag instead of the latest release
        required: false
        default: ""
        type: string
      dry_run:
        description: If true, don't dispatch; just print payload JSON
        required: false
        default: false
        type: boolean

permissions:
  contents: read

jobs:
  dispatch-website:
    name: Dispatch website from latest release
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout (for payload generator script)
        uses: actions/checkout@v6

      - name: Ensure dispatch token is available
        env:
          DISPATCH_TOKEN: ${{ secrets.REPO_DISPATCH_TOKEN }}
        run: |
          if [ -z "$DISPATCH_TOKEN" ]; then
            echo "Missing secret REPO_DISPATCH_TOKEN (PAT with access to dispatch to target repo)."
            exit 1
          fi

      - name: Resolve release to use (latest or by tag)
        id: rel
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SOURCE_OWNER: ${{ inputs.source_owner }}
          SOURCE_REPO: ${{ inputs.source_repo }}
          RELEASE_TAG: ${{ inputs.release_tag }}
        run: |
          set -euo pipefail

          api="https://api.github.com/repos/${SOURCE_OWNER}/${SOURCE_REPO}"

          if [ -n "${RELEASE_TAG}" ]; then
            url="${api}/releases/tags/${RELEASE_TAG}"
          else
            url="${api}/releases/latest"
          fi

          echo "Fetching release from: $url"

          # Store full release response
          curl -sS \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$url" > release.json

          # Extract fields without jq (runner should already have python3)
          python3 - <<'PY'
          import json
          import os

          with open("release.json","r",encoding="utf-8") as f:
            data = json.load(f)

          tag = (data.get("tag_name") or "").strip()
          published_at = (data.get("published_at") or "").strip()
          body = data.get("body") or ""

          if not tag:
            raise SystemExit("Release response missing tag_name")

          # Write body to a file (avoid multiline output issues)
          with open("release_body.txt","w",encoding="utf-8") as f:
            f.write(body)

          # Write to GitHub Actions outputs
          with open(os.environ["GITHUB_OUTPUT"],"a",encoding="utf-8") as f:
            f.write(f"tag={tag}\n")
            f.write(f"published_at={published_at}\n")
          PY

          echo "Resolved tag: ${{ steps.rel.outputs.tag }}"
          echo "Resolved published_at: ${{ steps.rel.outputs.published_at }}"

      - name: Print fetched release notes (for verification)
        env:
          RELEASE_TAG: ${{ steps.rel.outputs.tag }}
        run: |
          echo "=== Release tag: ${RELEASE_TAG} ==="
          echo "=== Release body (raw) ==="
          cat release_body.txt

      - name: Generate Keep a Changelog JSON payload using release_notes_to_kac_json.py
        env:
          RELEASE_TAG: ${{ steps.rel.outputs.tag }}
          RELEASE_PUBLISHED_AT: ${{ steps.rel.outputs.published_at }}
          SOURCE_REPO: ${{ inputs.source_owner }}/${{ inputs.source_repo }}
        run: |
          set -euo pipefail

          if [ ! -f ".github/scripts/release_notes_to_kac_json.py" ]; then
            echo "Missing .github/scripts/release_notes_to_kac_json.py in this repo."
            echo "Make sure it exists on the branch you are running this workflow from."
            exit 1
          fi

          # Reuse the exact generator script under test.
          # Pass the fetched release body via env (read from file to avoid YAML multiline issues).
          export RELEASE_BODY="$(cat release_body.txt)"

          python3 .github/scripts/release_notes_to_kac_json.py > release_payload.json

          echo "=== Generated payload (JSON) ==="
          cat release_payload.json

      - name: Dispatch event to website repo
        env:
          DISPATCH_TOKEN: ${{ secrets.REPO_DISPATCH_TOKEN }}
          OWNER: ${{ inputs.website_owner }}
          REPO: ${{ inputs.website_repo }}
          EVENT_TYPE: ${{ inputs.event_type }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          set -euo pipefail

          if [ "${DRY_RUN}" = "true" ]; then
            echo "dry_run=true â€” not dispatching."
            exit 0
          fi

          curl -sS -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $DISPATCH_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/$OWNER/$REPO/dispatches" \
            -d "$(python3 - <<'PY'
          import json, os

          with open("release_payload.json","r",encoding="utf-8") as f:
            payload = json.load(f)

          print(json.dumps({
            "event_type": os.environ["EVENT_TYPE"],
            "client_payload": payload
          }, ensure_ascii=False))
          PY
          )"
